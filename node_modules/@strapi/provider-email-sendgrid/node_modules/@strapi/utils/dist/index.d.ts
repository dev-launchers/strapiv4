/// <reference types="koa" />
/// <reference types="formidable" />
/// <reference types="lodash" />
import * as policy from './policy';
import * as errors from './errors';
import * as contentTypes from './content-types';
import * as relations from './relations';
import * as hooks from './hooks';
import * as pagination from './pagination';
import { pipeAsync } from './async';
import importDefault from './import-default';
import * as template from './template';
import * as file from './file';
import * as traverse from './traverse';
declare const _default: {
    parseMultipartData: (ctx: import("./types").Context) => import("koa").Context | {
        data: any;
        files: import("formidable").Files;
    };
    parseType: <Type extends keyof {
        boolean: boolean;
        integer: number;
        biginteger: number;
        float: number;
        decimal: number;
        time: string;
        date: string;
        timestamp: Date;
        datetime: Date;
    }>(options: import("./parse-type").ParseTypeOptions<Type>) => {
        boolean: boolean;
        integer: number;
        biginteger: number;
        float: number;
        decimal: number;
        time: string;
        date: string;
        timestamp: Date;
        datetime: Date;
    }[Type];
    policy: typeof policy;
    templateConfiguration: (obj: Record<string, unknown>, configPath?: string) => Record<string, unknown>;
    yup: typeof import("yup") & {
        strapiID: () => import("./validators").StrapiIDSchema;
    };
    handleYupError: (error: import("yup").ValidationError, errorMessage: string) => never;
    validateYupSchema: (schema: import("yup").AnySchema, options?: {}) => (body: unknown, errorMessage: string) => Promise<any>;
    validateYupSchemaSync: (schema: import("yup").AnySchema, options?: {}) => (body: unknown, errorMessage: string) => any;
    errors: typeof errors;
    nameToSlug: (name: string, options?: import("@sindresorhus/slugify").Options) => string;
    nameToCollectionName: (name: string) => string;
    getCommonBeginning: (...strings: string[]) => string;
    escapeQuery: (query: string, charsToEscape: string, escapeChar?: string) => string;
    stringIncludes: (arr: unknown[], val: unknown) => boolean;
    stringEquals: (a: unknown, b: unknown) => boolean;
    isKebabCase: (value: string) => boolean;
    isCamelCase: (value: string) => boolean;
    toRegressedEnumValue: (value: string) => string;
    startsWithANumber: (value: string) => boolean;
    joinBy: (joint: string, ...args: string[]) => string;
    toKebabCase: (value: string) => string;
    removeUndefined: <T extends object>(obj: T) => Partial<T>;
    keysDeep: (obj: object, path?: string[]) => string[];
    getConfigUrls: (config: import("./types").Config, forAdminBuild?: boolean) => {
        serverUrl: string;
        adminUrl: string;
        adminPath: string;
    };
    getAbsoluteAdminUrl: (config: import("./types").Config, forAdminBuild?: boolean) => string;
    getAbsoluteServerUrl: (config: import("./types").Config, forAdminBuild?: boolean) => string;
    generateTimestampCode: (date: Date) => string;
    contentTypes: typeof contentTypes;
    env: (<T_1>(key: string, defaultValue?: T_1 | undefined) => string | T_1 | undefined) & {
        int(key: string, defaultValue?: number | undefined): number | undefined;
        float(key: string, defaultValue?: number | undefined): number | undefined;
        bool(key: string, defaultValue?: boolean | undefined): boolean | undefined;
        json(key: string, defaultValue?: object | undefined): any;
        array(key: string, defaultValue?: string[] | undefined): string[] | undefined;
        date(key: string, defaultValue?: Date | undefined): Date | undefined;
        oneOf(key: string, expectedValues?: unknown[] | undefined, defaultValue?: unknown): unknown;
    };
    relations: typeof relations;
    setCreatorFields: <TData extends object>({ user, isEdition }: import("./set-creator-fields").Options) => <TDataInner extends object = TData>(data: TDataInner) => TDataInner;
    hooks: typeof hooks;
    providerFactory: import("./provider-factory").ProviderFactory;
    pagination: typeof pagination;
    sanitize: {
        contentAPI: {
            input: import("./sanitize").SanitizeFunc;
            output: import("./sanitize").SanitizeFunc;
            query: (query: Record<string, unknown>, schema: import("./types").Model, { auth }?: import("./sanitize").Options) => Promise<Record<string, unknown>>;
            filters: import("./sanitize").SanitizeFunc;
            sort: import("./sanitize").SanitizeFunc;
            fields: import("./sanitize").SanitizeFunc;
            populate: import("./sanitize").SanitizeFunc;
        };
        sanitizers: typeof import("./sanitize/sanitizers");
        visitors: typeof import("./sanitize/visitors");
    };
    validate: {
        contentAPI: {
            input: import("./validate").ValidateFunc;
            query: (query: Record<string, unknown>, schema: import("./types").Model, { auth }?: import("./validate").Options) => Promise<void>;
            filters: import("./validate").ValidateFunc;
            sort: import("./validate").ValidateFunc;
            fields: import("./validate").ValidateFunc;
        };
        validators: typeof import("./validate/validators");
        visitors: typeof import("./validate/visitors");
    };
    traverseEntity: import("lodash").CurriedFunction3<import("./traverse-entity").Visitor, import("./traverse-entity").TraverseOptions, import("./traverse-entity").Data, Promise<import("./traverse-entity").Data>>;
    pipeAsync: typeof pipeAsync;
    mapAsync: (...args: any[]) => any;
    reduceAsync: (mixedArray: any[]) => <T_2>(iteratee: (...args: any) => any, initialValue?: T_2 | undefined) => Promise<T_2 | undefined>;
    forEachAsync: <T_3, R>(array: T_3[], func: import("p-map").Mapper<T_3, R>, options: import("p-map").Options) => Promise<void>;
    convertQueryParams: {
        convertSortQueryParams: (sortQuery: string | string[] | import("./convert-query-params").SortParamsObject | import("./convert-query-params").SortParamsObject[]) => import("./convert-query-params").SortMap | import("./convert-query-params").SortMap[];
        convertStartQueryParams: (startQuery: unknown) => number;
        convertLimitQueryParams: (limitQuery: unknown) => number | undefined;
        convertPopulateQueryParams: (populate: string | string[] | import("./convert-query-params").PopulateAttributesParams, schema?: import("./types").Model | undefined, depth?: number) => boolean | string[] | {
            [key: string]: boolean | string[] | any;
        };
        convertFiltersQueryParams: (filters: unknown, schema?: import("./types").Model | undefined) => import("./convert-query-params").WhereQuery;
        convertFieldsQueryParams: (fields: string | string[], depth?: number) => (string | string[]) | undefined;
        convertPublicationStateParams: (schema?: import("./types").Model | undefined, params?: {
            publicationState?: "live" | "preview" | undefined;
        }, query?: import("./convert-query-params").Query) => void;
        transformParamsToQuery: (uid: string, params: import("./convert-query-params").Params) => import("./convert-query-params").Query;
    };
    importDefault: typeof importDefault;
    template: typeof template;
    file: typeof file;
    traverse: typeof traverse;
    webhook: {
        webhookEvents: {
            [x: string]: string;
        };
    };
    isOperator: (key: string, ignoreCase?: boolean) => boolean;
    isOperatorOfType: (type: string, key: string, ignoreCase?: boolean) => boolean;
};
export = _default;

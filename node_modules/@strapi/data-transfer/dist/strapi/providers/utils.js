"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trimTrailingSlash = exports.connectToWebsocket = exports.createDispatcher = void 0;
const crypto_1 = require("crypto");
const ws_1 = require("ws");
const providers_1 = require("../../errors/providers");
const createDispatcher = (ws, retryMessageOptions = {
    retryMessageMaxRetries: 5,
    retryMessageTimeout: 15000,
}) => {
    const state = {};
    const dispatch = async (message, options = {}) => {
        if (!ws) {
            throw new Error('No websocket connection found');
        }
        return new Promise((resolve, reject) => {
            const uuid = (0, crypto_1.randomUUID)();
            const payload = { ...message, uuid };
            let numberOfTimesMessageWasSent = 0;
            if (options.attachTransfer) {
                Object.assign(payload, { transferID: state.transfer?.id });
            }
            const stringifiedPayload = JSON.stringify(payload);
            ws.send(stringifiedPayload, (error) => {
                if (error) {
                    reject(error);
                }
            });
            const { retryMessageMaxRetries, retryMessageTimeout } = retryMessageOptions;
            const sendPeriodically = () => {
                if (numberOfTimesMessageWasSent <= retryMessageMaxRetries) {
                    numberOfTimesMessageWasSent += 1;
                    ws.send(stringifiedPayload, (error) => {
                        if (error) {
                            reject(error);
                        }
                    });
                }
                else {
                    reject(new providers_1.ProviderError('error', 'Request timed out'));
                }
            };
            const interval = setInterval(sendPeriodically, retryMessageTimeout);
            const onResponse = (raw) => {
                const response = JSON.parse(raw.toString());
                if (response.uuid === uuid) {
                    clearInterval(interval);
                    if (response.error) {
                        const message = response.error.message;
                        const details = response.error.details?.details;
                        const step = response.error.details?.step;
                        let error = new providers_1.ProviderError('error', message, details);
                        if (step === 'transfer') {
                            error = new providers_1.ProviderTransferError(message, details);
                        }
                        else if (step === 'validation') {
                            error = new providers_1.ProviderValidationError(message, details);
                        }
                        else if (step === 'initialization') {
                            error = new providers_1.ProviderInitializationError(message);
                        }
                        return reject(error);
                    }
                    resolve(response.data ?? null);
                }
                else {
                    ws.once('message', onResponse);
                }
            };
            ws.once('message', onResponse);
        });
    };
    const dispatchCommand = (payload) => {
        return dispatch({ type: 'command', ...payload });
    };
    const dispatchTransferAction = async (action) => {
        const payload = { type: 'transfer', kind: 'action', action };
        return dispatch(payload, { attachTransfer: true }) ?? Promise.resolve(null);
    };
    const dispatchTransferStep = async (payload) => {
        const message = {
            type: 'transfer',
            kind: 'step',
            ...payload,
        };
        return dispatch(message, { attachTransfer: true }) ?? Promise.resolve(null);
    };
    const setTransferProperties = (properties) => {
        state.transfer = { ...properties };
    };
    return {
        get transferID() {
            return state.transfer?.id;
        },
        get transferKind() {
            return state.transfer?.kind;
        },
        setTransferProperties,
        dispatch,
        dispatchCommand,
        dispatchTransferAction,
        dispatchTransferStep,
    };
};
exports.createDispatcher = createDispatcher;
const connectToWebsocket = (address, options) => {
    return new Promise((resolve, reject) => {
        const server = new ws_1.WebSocket(address, options);
        server.once('open', () => {
            resolve(server);
        });
        server.on('unexpected-response', (_req, res) => {
            if (res.statusCode === 401) {
                return reject(new providers_1.ProviderInitializationError('Failed to initialize the connection: Authentication Error'));
            }
            if (res.statusCode === 403) {
                return reject(new providers_1.ProviderInitializationError('Failed to initialize the connection: Authorization Error'));
            }
            if (res.statusCode === 404) {
                return reject(new providers_1.ProviderInitializationError('Failed to initialize the connection: Data transfer is not enabled on the remote host'));
            }
            return reject(new providers_1.ProviderInitializationError(`Failed to initialize the connection: Unexpected server response ${res.statusCode}`));
        });
        server.once('error', (err) => {
            reject(new providers_1.ProviderTransferError(err.message, {
                details: {
                    error: err.message,
                },
            }));
        });
    });
};
exports.connectToWebsocket = connectToWebsocket;
const trimTrailingSlash = (input) => {
    return input.replace(/\/$/, '');
};
exports.trimTrailingSlash = trimTrailingSlash;
//# sourceMappingURL=utils.js.map
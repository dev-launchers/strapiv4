"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultValidateFields = exports.defaultValidateSort = exports.defaultValidateFilters = exports.throwPasswords = void 0;
const fp_1 = require("lodash/fp");
const async_1 = require("../async");
const traverse_entity_1 = __importDefault(require("../traverse-entity"));
const content_types_1 = require("../content-types");
const traverse_1 = require("../traverse");
const visitors_1 = require("./visitors");
const operators_1 = require("../operators");
const utils_1 = require("./utils");
const throwPasswords = (schema) => async (entity) => {
    if (!schema) {
        throw new Error('Missing schema in throwPasswords');
    }
    return (0, traverse_entity_1.default)(visitors_1.throwPassword, { schema }, entity);
};
exports.throwPasswords = throwPasswords;
const defaultValidateFilters = (0, fp_1.curry)((schema, filters) => {
    // TODO: schema checks should check that it is a validate schema with yup
    if (!schema) {
        throw new Error('Missing schema in defaultValidateFilters');
    }
    return (0, async_1.pipeAsync)(
    // keys that are not attributes or valid operators
    (0, traverse_1.traverseQueryFilters)(({ key, attribute }) => {
        // ID is not an attribute per se, so we need to make
        // an extra check to ensure we're not removing it
        if (key === 'id') {
            return;
        }
        const isAttribute = !!attribute;
        if (!isAttribute && !(0, operators_1.isOperator)(key)) {
            (0, utils_1.throwInvalidParam)({ key });
        }
    }, { schema }), 
    // dynamic zones from filters
    (0, traverse_1.traverseQueryFilters)(visitors_1.throwDynamicZones, { schema }), 
    // morphTo relations from filters; because you can't have deep filtering on morph relations
    (0, traverse_1.traverseQueryFilters)(visitors_1.throwMorphToRelations, { schema }), 
    // passwords from filters
    (0, traverse_1.traverseQueryFilters)(visitors_1.throwPassword, { schema }), 
    // private from filters
    (0, traverse_1.traverseQueryFilters)(visitors_1.throwPrivate, { schema }), 
    // empty objects
    (0, traverse_1.traverseQueryFilters)(({ key, value }) => {
        if ((0, fp_1.isObject)(value) && (0, fp_1.isEmpty)(value)) {
            (0, utils_1.throwInvalidParam)({ key });
        }
    }, { schema }))(filters);
});
exports.defaultValidateFilters = defaultValidateFilters;
const defaultValidateSort = (0, fp_1.curry)((schema, sort) => {
    if (!schema) {
        throw new Error('Missing schema in defaultValidateSort');
    }
    return (0, async_1.pipeAsync)(
    // non attribute keys
    (0, traverse_1.traverseQuerySort)(({ key, attribute }) => {
        // ID is not an attribute per se, so we need to make
        // an extra check to ensure we're not removing it
        if (key === 'id') {
            return;
        }
        if (!attribute) {
            (0, utils_1.throwInvalidParam)({ key });
        }
    }, { schema }), 
    // dynamic zones from sort
    (0, traverse_1.traverseQuerySort)(visitors_1.throwDynamicZones, { schema }), 
    // morphTo relations from sort
    (0, traverse_1.traverseQuerySort)(visitors_1.throwMorphToRelations, { schema }), 
    // private from sort
    (0, traverse_1.traverseQuerySort)(visitors_1.throwPrivate, { schema }), 
    // passwords from filters
    (0, traverse_1.traverseQuerySort)(visitors_1.throwPassword, { schema }), 
    // keys for empty non-scalar values
    (0, traverse_1.traverseQuerySort)(({ key, attribute, value }) => {
        // ID is not an attribute per se, so we need to make
        // an extra check to ensure we're not removing it
        if (key === 'id') {
            return;
        }
        if (!(0, content_types_1.isScalarAttribute)(attribute) && (0, fp_1.isEmpty)(value)) {
            (0, utils_1.throwInvalidParam)({ key });
        }
    }, { schema }))(sort);
});
exports.defaultValidateSort = defaultValidateSort;
const defaultValidateFields = (0, fp_1.curry)((schema, fields) => {
    if (!schema) {
        throw new Error('Missing schema in defaultValidateFields');
    }
    return (0, async_1.pipeAsync)(
    // Only allow scalar attributes
    (0, traverse_1.traverseQueryFields)(({ key, attribute }) => {
        // ID is not an attribute per se, so we need to make
        // an extra check to ensure we're not removing it
        if (key === 'id') {
            return;
        }
        if ((0, fp_1.isNil)(attribute) || !(0, content_types_1.isScalarAttribute)(attribute)) {
            (0, utils_1.throwInvalidParam)({ key });
        }
    }, { schema }), 
    // private fields
    (0, traverse_1.traverseQueryFields)(visitors_1.throwPrivate, { schema }), 
    // password fields
    (0, traverse_1.traverseQueryFields)(visitors_1.throwPassword, { schema }))(fields);
});
exports.defaultValidateFields = defaultValidateFields;
//# sourceMappingURL=validators.js.map